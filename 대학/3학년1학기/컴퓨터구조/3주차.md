### Instruction Set
- 컴퓨터의 instruction 레퍼토리이다(수행해야 하는 목록)
- 컴퓨터 마다 instruction set 다름
- 가능한 간단하게 만들수록 좋음
- 우리는 RISC-V 의 Instruction set를 사용

### Arithmetic Operation(산술 연산)
`add a,b,c // a gets b+c`
-> Two sources and one destination

==Design Principle 1: Simplicity favours regularity==

C Code:
`f = (g+h) - (i+j)`

Compiled RISC-V code:

`add t0, g, h // temp t0 = g+h`
`add t1, i, j // temp t1 = i + j`
`add f, t0, t1 // f=t0-t1`
-> 왜 빼기도 add 임? 여기서는 구분하지 않음

RISC-V 는 32개의 64-bit 레지스터를 가지고 있다.

64-bit data는 doubleword 라고 부름
32-bit data는 word 라고 부름
- 왜 32개로 제한함? Cost때문


==Design Principle 2: Smaller is faster==



### RISC-V Registers
- x0
- x1
- x2
- x3
- x4
- x5-x7, x28-x31
- x8
- x9, x18
- x12 -x17
- 등.....각각의 레지스터는 쓰이는 목적이 다름

### Register Operand Example
C code:
`f = (g+h) - (i+j)`
f,...,j in x19, x20,...., x23

Compiled RISC-V code:
`add x5, x20, x21`
`add x6, x22, x23`
`sub x19, x5, x6` (여기서 sub는 가상의 연산자)

### Memory Operands
- 복잡한 데이터들(배열, 구조체, 동적데이터): 메모리 사용(휘발성)
	- 메모리에서 레지스터로 Load 함
	- 결과를 레지스터에서 메모리로 Store함
- 메모리의 주소: 8-bit
- RISC-V는 [[Little Endian]] 방식 사용
- Risc-V 는 words 가 메모리에 정렬되어 있지 않아도 됨(?)

Example
C code:
`A[12] = h + A[8];`
- h in x21, base address of A in x22
RISC-V:
- Index 8 requires offsset of 64
	- 8 bytes per doubleword
`ld    x9, 64(x22)`<- Load
`add   x9, x21, x9`
`sd    x9, 96(x22)`<- Store

하나당 8 이니까 `A[12]` 는 base인 x22에서 12번째(12x8) 해서 96(x22)

### Registers vs. Memory
- 레지스터는 메모리보다 빠르다
- 메모리에 데이터를 접근하려면 Load 와 Store가 필요
	- Instruction 이 더 필요하다는 뜻
- 컴파일러는 레지스터를 최대한 많이 사용해야한다(빨라서)

### Immediate Operands
- Constant data specified in an instruction
	- 하나의 Operand가 상수값을 갖는 경우
`addi x22, x22, 4`-> 상수인 '4'가 있음
- Make the common case fast 의 부분임

### Unsigned Binary Integers
- 컴퓨터는 모든 수를 이진수로 표현함
- Range: $0\;to\;2^n-1$

### 2s- Complement Signed Integers
- 음수표현도 해야되므로~
- Range: $-2^{(n-1)}\;to\;2^{(n-1)}-1$ 
	- 끝에 -1 은 0을 포함해서 그럼
- 음수표현은 어떻게 하냐
	- 제일 왼쪽 비트가 1인지 0인지에 따라 달라짐
### Signed Negation
- 그래서 이진수 사용할 때 이진수를 십진수로 변환할 때 2의 보수 관계를 사용
- 어떤 이진수를 음수로 바꾸기 위해서는 모든 자릿수를 보수처리(NOT)하고 1더하면 됨
### Signed Extention(부호확장)
- 비트수를 확장할 때 사용 (8-bit -> 32-bit)
- 가장 왼쪽에 수를 그냥 쭉 늘림
-  2  : `0000 0010` => `0000 0000 0000 0010`
- -2 : `1111 1110` => `1111 1111 1111 1110`
- RISC-V 에서는
	- 1b: sign-extend(왼쪽 부호로)
	- 1bu: zero-extend(0으로)


Base16: 16진수법

### Representing Instruction
- Instruction 도 이진수로 인코딩된다(= machine code)
- 1 word = 4 bytes = 32bits
	- 이때 32bits 의 instruction 을 ==fields==로 나눌 수 있다
	- 왜 여러개의 field?
		- 하나의 format 만 사용하면 상황별에 따라 표현이 불가능할 수 있음
- **R-format**
	- add 와 같은 산술연산, 논리연산 등에 사용됨
	- 6개의 fields
	- 7 / 5 / 5 / 3 / 5 / 7 로 이루어짐
- **I-format**
	- Immediate Operation, 메모리 접근 등에 사용됨
	- 5개의 fields
	- 12 / 5 / 3 / 5 / 7 로 이루어짐
- S-format
	- Store 연산을 위해 사용됨
	- 6개의 field
	- 7 / 5 / 5 / 3 / 5 / 7 로 이루어짐


> [!note]
> 명령어들도 Data와 같이 Binary로 표현됨. 
> 그러므로 Data와 같이 메모리에 저장됨.
> Binary로 표현되기 때문에 같은 ISA라면 다른 컴퓨터에서도 동일하게 동작함

>[!summary]
>1. Instruction 의 개념
>2. Instruction 이 컴퓨터에 어떻게 저장되고 사용되는지
>3. HLL->Assembly->Binary 의 과정 
