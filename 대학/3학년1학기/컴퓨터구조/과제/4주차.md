## EX1:
`addi x7, x0, 0x3f ` //x7에 x0 값에 0x3f(binary 0011 1111) 더함
`slli x7, x7, 11`      //bit mask 만들기 위해 11만큼(0 to 11) 이동
`and x28, x5, x7`      //만든 bit mask 사용해서 필요한 데이터 추출
`slli x7, x7, 15`      //31-26 범위용 bit mask 
`xori x7, x7, -1`      //mask를 뒤집음 (삽입용 mask)
`and x6, x6, x7`       //31-26 이 0으로 초기화된 x6
`slli x28, x28, 15`  //아까 추출해둔 데이터 삽입하기 위해 이동
`or x6, x6, x28`       //데이터 삽입


## EX2:
`bge x5, x0, ELSE`        //x5 는 x0보다 크므로 ELSE로 branch
`jal x0, DONE`                //DONE으로 unconditional jump, 
`ELSE: ori x6, x0, 2`    //x0과 or은 그냥 수 자체임으로 x6에 2를 load함
`DONE:`

'2'의 값이므로
00000000 00000000 00000010


## EX3:
2.24.1
10 에서 1씩 빼면 Loop cycle은 10번 돈다.
그러므로 2를 10번 더해 x5에는 **20**이 들어가있음.

2.24.2
```C
acc = 0;
i = 10;
while(i!=0){
	acc += 2;
	i--;

}
```

2.24.3
Condition 문 (beq) 1개의 instruction
다음 condition문 까지 4개의 instruction의 loop N번
-> 4*N+1 instructions

2.24.4
조건문을 beq로 바꾸면~
```C
acc = 0;
i = 10;
while(i>=0){
	acc += 2;
	i--;

}
```

### EX4:
`addi x2, x2, -8`   //stack 공간 확보(4byte 2개)
`sw x1, 0(x2)`        //x1의 값을 x2의 top 에 저장 (0-3)
`add x5, x12, x13` //x5에 x12 + x13 값 저장
`sw x5, 4(x2)`        //x5의 값을 x2의 top 에서 4번째에 저장 (4byte) 
`jal x1, g`             //x1에 원래 읽던거 저장해두고 g로 jump
`lw x11, 4(x2)`      //아까 한 c+d(x12, x13) 을 x11에 load
`jal x1, g`             //두번째 g 호출
`lw x1, 0(x2)`       //원래 x1 값 stack에서 restore 하기
`addi x2, x2, 8`   //stack pointer 를 다시 복
`jalr x0, x1`        //x1로 jump, x0을 사용해서 링크 주소 필요X