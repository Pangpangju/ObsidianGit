## EX1:
`addi x7, x0, 0x3f ` //x7에 x0 값에 0x3f(binary 0011 1111) 더함`
`slli x7, x7, 11`      //bit mask 만들기 위해 11만큼 이동
`and x28, x5, x7`      //만든 bit mask 사용해서 필요한 데이터 추출
`slli x7, x7, 15`      //31-26 범위용 bit mask 
`xori x7, x7, -1`      //mask를 뒤집음 (삽입용 mask)
`and x6, x6, x7`       //31-26 이 0으로 초기화된 x6
`slli x28, x28, 15`  //아까 추출해둔 데이터 삽입하기 위해 이동
`or x6, x6, x28`       //데이터 삽입


## EX2:
`bge x5, x0, ELSE`        //x5 는 x0보다 크므로 ELSE로 branch
`jal x0, DONE`                //DONE으로 unconditional jump, 
`ELSE: ori x6, x0, 2`    //x0과 or은 그냥 수 자체임으로 x6에 2를 load함
`DONE:`

'2'의 값이므로
00000000 00000000 00000010


## EX3:
2.24.1
10 에서 1씩 빼면 Loop cycle은 10번 돈다.
그러므로 2를 10번 더해 x5에는 **20**이 들어가있음.

2.24.2
```C
acc = 0;
i = 10;
while(i!=0){
	acc += 2;
	i--;

}
```

2.24.3
Condition 문 (beq) 1개의 instruction
다음 condition문 까지 4개의 instruction의 loop N번
-> 4*N+1 instructions

2.24.4
조건문을 beq로 바꾸면~
```C
acc = 0;
i = 10;
while(i>=0){
	acc += 2;
	i--;

}
```

### EX4:
`addi x2, x2, -8`   //stack 공간 확보
`sw x1, 0(x2)`
`add x5, x12, x13`
`sw x5, 4(x2)`
`jal x1, g`
`lw x11, 4(x2)`
`jal x1, g`
`lw x1, 0(x2)`
`addi x2, x2, 8`
`jalr x0, x1`