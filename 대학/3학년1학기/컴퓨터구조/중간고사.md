### Chapter 1.
#### 1.1 
- Personal (PC), Server, Embeded
#### 1.2
- 알아서 맞추기
#### 1.3
- Assembly 의 특성
#### 1.4
- 8 bits ==for== primary colors(3개)
#### 1.5
- ?
#### 1.6
- Time = CPI * NOI / Clock Rate
#### 1.7
- 똑같은 공식 쓰면 됨
#### 1.8
- 똑같은 공식 쓰면 됨
#### 1.9
- $C = 2 \times DP/(V^2 \times F)$ (Dynamic Power)
- static 에 대한 dynamic 비율 구하기
- $(S_{new}+D_{new})/(S_{old}+D_{old})=0.90$
- $D_{new}=C\times V_{new}\times 2\times F$
- $S_{old}=V_{old}\times I$
- $S_{new}=V_{new}\times I$
#### 1.10
arithmetic load/store branch
1 12 5
2.56E9 arithmetic instructions, 1.28E9 load/store
256million branch instructions
2GHz clock frequency

/0.7 p

T = instructions * CPI / CLockRate
(1*2.56E9/0.7 + 12 * 1.28E9/0.7 + 5 X 2.56E9)

#### 1.11
컷
#### 1.12
clock rate = 1/cycle time = 3GHz

750s = 2.389E12 X CPI / 3*10^9 

1.1 * 1.05  = 1.1 + 0.05*1.1 1.155

#### 1.13
P1 
4GHz 0.9 5.0E9 instruction
P2
3GHz 0.75 1.0E9

MIPS = NOI / (실행시간*10^6)

#### 1.14
250 = 70(FP) + 85(L/S) + 40(Branching)

#### 1.15
50 fp  110 INT  80 L/S 16 Branch
1   1    4    2
2GHz
50 110 320 32     198  80 4 x = 58
256
512 

80 X newCPI = 256 
new CPI = 256/80

4/3.2

4 x = 58/80 29/40


### Chapter 2
#### 2.1
addi x7 x7 (-5)
add x5 x6 x7

#### 2.2
f = g+h+i

#### 2.3
sub x30 x28 x29
slli x30 x30 3
add x3 x30 x10
ld x30 0(x3)
sd x30 64(x11)

#### 2.4
- 메모리값 `&A[0]` 이런데에다가 8 더하면
- `&A[0]+ 8 = &A[1]`이낌
`x30 에 A[f]
`x31에 B[g]
`f 에 A[f]값

`x12에 A[f]에 8 더함
`x30 에 A[f+1]
`B에다가 A[f+1]
`B[g] = A[f]+A[f+1]

#### 2.5
- Little 엔디안은 오른쪽에서부터 
- Big 은 왼쪽에서부터

#### 2.6
1010 1011 1100 1101 1110 1111 0001 0010

#### 2.7
slli x28 x28 3
add x10 x10 x28
ld x28 0(x10)
slli x29 x29 3
add x11 x11 x29
ld x29 0(x11)
add x29 x29 x28
sd x29 64(x11)


#### 2.8
`x30 에 &A[1]
`x31 에 &A[0]`
`A[1] = &A`
`x30 = &A`
`f = 2*(&A)`

#### 2.9
주겄지...

#### 2.10
- 0x5000000000~
- overflow
- 0xB000~
- no overflow
- 0XD000~
- overflow
a - b = c

1000
1101
0011

1011

#### 2.11
x5 128 = 1000 0000
0111 1111
overflow 2^63 -1
128 + x > 2^63 -1
x > 2^63-129

x - 128 < -2^63


#### 2.12
format

#### 2.13
format

#### 2.14
format

#### 2.15 
format

#### 2.16
4배 로 늘어나니까 4 (binary로는 shift 2) 해야됨 
늘어나는값만!

#### 2.17
0x0 0 0 0 A A A A A A A A 0 0 0 0

0000 0000 0000 0000 1010 1010 1010 1010 1010 1010 1010 1010 0000 0000 0000 0000

0001 0010 0011 0100 0101 0110 0111 1000 0001 0010 0011 0100 0101 0110 0111 1000

0001 0010 0011 0100 1111 1110 1111 1010 1011 1010 1011 1110 0101 0110 0111 1000

0x1 2 3 4 5 6  7  8 1  2 3 4  5 6 7 8
1234 FEFA BABE 5678

#### 2.18
addi x7 x0 0011 1111
slli x7 x7 11
and x28 x7 x5
slli x28 x28 15

#### 2.19 
xori x5 x6 -1

#### 2.20
ld x6 0(x17) //메모리 로드하는거니까
slli x6 x6 4

#### 2.21
2

#### 2.22
- UJ format 이라 이동 범위 (-2^19 ~ 2^19-1)

#### 2.23
- UJ 
- 마지막에 하나 더해줘야하는거 잊지말기

#### 2.24
acc = 0;
i = 10;

#### 2.25

addi x7 x0 0
LOOPI:
addi x29 x0 0
bge  x7 x5 ENDI //바깥 for문 끝나면 끝
addi x30 x10 0
addi x29 x0 0

LOOPJ:
bge x29 x6 ENDJ
add x31 x7 x29
sd x31 0(x30)
addi x30, x30, 32 
addi x29 x29 1
jal x0 LOOPJ


ENDJ:
addi x7 x7 1
jal x0 LOOPI


ENDI:
끗


#### 2.26
12 or 13

#### 2.27
result 에 0
x29 에 100

loop
`x7 에 MemArray[0]
`i += MemArray[]
`Memarray index 1 추가
`result += 1
`result < 100 하면 loop

`for (i = 0; i < 100; i++){
``	result += MemArray[i]
`}


#### 2.28
add x29 x10 800

loop:
ld x7, 0(x10)
add x5 x5 x7
addi x10 8 

bge x29 x10 loop

#### 2.29
- 왜 16의 배수죠?
fib:
beq x10 x0 done
addi x5, x0, 1
beq x10 x5, done
addi x2, x2, -16

sd x0 0(x2)
sd x10 8(x2)
addi x10 x10 -1
jal x1 fib
ld x5 8(x2)

done:
jalr x0 x1
#### 2.30
- ㄲㅈ

#### 2.31
f:
addi x2 x2 -16
sd x1 0(x2)
add x5 x12 x13 //(c+d)
sd x5 8(x2)
jal x1 g
ld x11 8(x2)
jal x1 g
ld x1 0(x2)
addi x2 x2 16
jalr x0 x1
g:

#### 2.32
jalr 없어도됨

#### 2.33

#### 2.34

#### 2.35
- Little, big endian
- 8이니까 2개

#### 2.36
11223344
55667788
몰?르?

#### 2.37*

`try:`
`lr.d x5 (x10)`
`bge x5 x11`
`addi x11 x0 x5`
`release:`
`sc.d x7 x5 (x10)`
`bne x7 x0 try`
`jalr x0 x1`


#### 2.38
