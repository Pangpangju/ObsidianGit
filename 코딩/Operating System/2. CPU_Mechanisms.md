
우리는 전에 [[시분할]]을 사용해서 CPU가 여러 프로세스를 동시에 실행한다고 **<font color="#c0504d">생각되게</font>** 만든다고 배웠음

근데 여기서 문제,

##### 1. 성능저하
*어떻게 시스템에 과중한 오버헤드를 주지 않을까?*
##### 2. 제어문제
*CPU에 대한 통제를 유지하면서 프로세스를 효율적으로 실행시킬 수 있을까?*

## 제한적 직접 실행 원리

> [!abstract] 직접실행?
> 프로그램을 CPU 상에서 그냥 직접 실행시키는 것.
> OS 가 프로그램 실행하면 프로세스 목록에 해당 프로세스 항목을 만들고 메모리 할당함.

근데 이 접근법은 몇 가지 문제가 있음.
1. 프로그램을 직접 실행키면 OS의 효율성을 어떻게 보장할 것인지?[^1]
2. 프로세스 실행 시 어떻게 프로그램의 실행을 중단하고 다른 프로세스로 넘어가지?[^2]

이러한 이유 때문에 =="제한적"== 이라는 term 이 강조됨.

### 문제점 1: 제한된 연산

직접 실행은 속도가 장점이다, 하드웨어 CPU 에서 실행되기 때문.

**그러나 프로세스는 시스템에 대한 권한이 없기 떄문제 제한된 연산의 수행이 불가능하다.**

이 문제를 해결하기 위해 ==사용자 모드(User mode)== 그리고 ==커널 모드(Kernal mode)== 가 도입됨

#### 사용자 모드
- 실행되는 코드는 할 수 있는 일이 제한됨
- EX) 프로세스의 입출력 요구 컷

#### 커널 모드
- OS의 중요한 코드들이 실행됨
- 특수한 명령어를 포함하여 원하는 모든 작업 수행 가능

**그러나 사용자 프로세스가 특수한 명령어를 실행해야된다면??**

#### 시스템 콜
Atlas 와 같은 커널은 시스템 콜을 통하여 주요 기능을 사용자 프로그램에게 제공.

이를 실행하기 위해서는 ==trap 특수 명령어==를 실행해야 한다.
이는 커널 안으로 분기하는 동시에 perm 을 커널모드로 상향 조정함.
완료되면 ==return-from-trap 특수 명령어==를 호출하여 다시 하양조정함

> [!note] Return-from-trap 과정
> trap 명령이 실행되면 프로세스는 pc, flag, register 정보를 kernel stack에 넣는다.
> 그 후 return-from-trap 명령이 수행되면 이 데이터를 모두 pop하여 다시 User mode에서 사용할 수 있게 한다.

여담: [[프로시저 콜 vs. 시스템 콜]]

커널은 부팅시에 ==트랩 테이블(trap table)==을 만들고 이를 이용하여 시스템을 통제한다.
여기에는 각 명령어를 실행하기 위한 ==트랩 핸들러(trap handler)==가 들어있음

OS는 하드웨어에게 ==트랩 핸들러의 위치를 알려주고== 해당 위치를 알고 있는 하드웨어는 예외적인 사건이 발생했을 때 무엇을 해야할지(어느 코드로 분기하여 실행할지) 알 수 있다.
(이는 키보드 인터럽트 등 다양한 상황에서 사용)

- 부팅시 trap table 초기화
- 프로세스가 생성되면 user mode에서 실행
- kernel mode에서 실행이 필요하면 ( system call 이 발생하면), trap 되고 그 후 시스템 콜이 종료되면 return-from-trap을 통해 다시 user mode로 복귀.
- 프로세스 작업이 끝나면, 프로세스를 제거

### 문제점 2: 프로세스 간 전환

만약 CPU에서 프로세스가 실행중이라는 것은 <font color="#c0504d">운영체제는 실행중이지 않다는 것</font>을 의미한다.

그렇다면, 운영체제가 실행되지 않는데 어떻게 프로세스 간 전환을 할 수 있을까?

$$CPU를\; 어떻게\; 다시\; 획득할\; 수\; 있는가$$

#### 협조 방식: 시스템 콜 기다리기
옛날에는 운영체제가 프로세스들이 합리적으로 행동할 것이라고 신뢰했다. 
너무 오랫동안 실행할 가능성이 있는 프로세스는 CPU를 포기할 것이라고 가정함.

그럼 어떻게 포기하는데?

프로세스는 ==시스템 콜== 을 호출하여 CPU의 제어권을 OS에게 넘겨준다.
- **yield** 시스템 콜을 사용한다.
응용 프로그램이 비정상적인 행위 (버그, 실행 불가한 연산, 접근불가 메모리 접근)를 하게 되면 운영체제로의 ==트랩==이 일어난다. 
그럼 CPU를 획득하여 프로세스를 종료할 수 있다.

**그런데** 시스템 콜을 호출할 수 없을 때에는 어떤 일이 벌어질까? 
Ex) 무한 루프

#### 비협조 방식 : 운영체제가 전권을 행사
협조적 방식에서 무한루프를 어떻게 해결할까?

정답은......



$$재 \;\;부\;\; 팅$$

이것의 해결책은 [[타이머 인터럽트(Timer interrupt)]]를 이용하는 것이다.

OS가 CPU에 대한 권한을 다시 획득하면 현재 실행중인 프로세스를 계속 실행한 것인지 아니면 다른 프로세스로 전환할 것인지를 결정해야 한다.

이때 [[스케줄러(Scheduler)]]라는 부분에 의해 내려진다.
전환이 결정되면 OS는 [[문맥 교환(Context switch)]] 코드를 실행함.

#### 병행성이 걱정돼
"만약 시스템 콜을 처리하는 도중에 타이머 인터럽트가 발생하면 어떤 일이 벌어질까?"
"하나의 인터럽트를 처리하고 있을 때 다른 인터럽트가 발생하면 어떤 일이 생길까?"
"그럼 커널에서 처리하기 더 어려운거 아닐까?"

- 인터럽트를 처리하는 동안에는 ==인터럽트를 불능화시킴==
- OS는 내부 자료 구조에 동시에 접근하는 것을 방지하기 위해 많은 정교한 ==락(lock)== 기법을 개발해 왔음.

---

[^1]: [[제한된 연산]]
[^2]: 프로세스 간 전환