MLFQ 는 스케줄링 기법중 하나이다.

의의
1. 짧은 작업을 먼저 실행시켜 반환 시간 최적화
2. 대화형 사용자를 위해 응답 시간 최적화

그런데, 어떻게 <font color="#d83931">프로세스에 대한 정보가 없이</font> 이러한 스케줄러를 만들 수 있을까?

### 기본 규칙
MLFQ 는 여러개의 ==큐(Queue)== 로 구성되며 각각 다른 ==우선순위(Priority Level)==가 배정된다

큐에는 둘 이상의 작업이 존재할 수 있다
- 이들은 모두 같은 우선순위를 가짐
- 이 작업들 사이에은 RR 알고리즘을 적용

핵심은 우선순위를 정하는 방식이다.
- 각 작업의 ==특성==에 따라 동적으로 우선순위를 부여한다.
	- EX) 키보드 인터럽트(대화형)에 높은 우선순위를 부여한다.

**규칙 1:** Priority(A) > Priority(B)이면, A가 실행됨
**규칙 2:** Priority(A) = Priority(B)이면, A 와 B는 RR 방식으로 실행됨
**규칙 3:** 작업이 시스템에 진입하면, 가장 높은 우선순위를 가진다.(=맨 위의 큐)
**규칙 4a:** 주어진 타임 슬라이스를 모두 사용하면 우선순위는 낮아진다(=한 단계 아래 큐로 이동)
**규칙4b:** 타임 슬라이스를 소진하기 전에 CPU를 양도하면 *같은* 우선순위를 유지한다.


##### <font color="#c0504d">이 알고리즘의 핵심:</font>
작업이 짧은 작업인지 긴 작업인지 모르니까 일단 짧은 작업이라고 가정하여 높은 우선순위를 부여.
- 진짜 짧은 작업은 빨리 종료
- 짧은 작업이 아니면 밑에 큐로 점점 내려감.

이로써...
$$MLFQ는\;SJF를\;근사한다.$$

### 문제점
1. [[기아 상태(Starvation)]]이 발생할 수 있다.
2. 사용자가 스케줄러를 자신에게 유리하게 동작하도록 작성한다면 CPU를 독점할 수 있음.
3. 프로그램은 시간 흐름에 따라 ==특성이 변할 수 있다.==(=CPU 위주 작업이 대화형 작업으로)

### 해결 방안
##### [[기아 상태(Starvation)]], 특성의 변화
간단한 아이디어,

> "모든 작업의 우선순위를 상향 조정(boost) 하면 어떨까?"

![[좋았쓰.png]]

**규칙5:** ==일정 기간 S가== 지나면, 시스템의 모든 작업을 최상위 큐로 이동시킨다.

이것은 두가지 문제를 한번에 해결한다.
1. 프로세스는 굶지 않게 된다!
2. 작업의 특성이 변해도 OK! 

물론 일정 기간 S를 정해야되는데 좀 어려움
- 너무 크면 작업이 굶을 수 있음
- 작으면 알고리즘 의미 없어짐

#### CPU 점령 방지
각 단계에서 CPU 총 사용 시간 측정하면 됨.

프로세스가 타임 슬라이스에 해당하는 시간을 모두 소진하면 다음 우선순위 큐로 강등된다.

**규칙 4a, 규칙4b**를 합쳐서 새로운 규칙을 지정하면:

**규칙 4:** 주어진 단계에서 시간 할당향을 소진하면 우선순위는 낮아진다.