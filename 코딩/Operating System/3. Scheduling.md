> [!note] 스케줄링이란?
> 스케줄링은 다중 프로그래밍을 가능하게 하는 운영체제의 동작기법. 자세히는 CPU의 자원의 배정을 적절하게 하는 행위

#### 스케줄링 정책은 어떻게 개발하는가?
###### 워크로드에 대한 가정

프로세스들이 실행하는 상황을 ==워크로드(workload)== 라고 부르기로 가정한다.

프로세스 혹은 작업(job)에 대해 다음과 같은 가정을 한다
1. 모든 작업은 같은 시간 동안 실행된다.
2. 모든 작업은 동시에 도착한다.
3. 각 작업은 시작되면 완료될 때까지 실행된다.
4. 모든 작업은 CPU만 사용한다.(I/O 없음)
5. 각 작업의 실행 시간은 사전에 알려져 있다.

#### 스케줄링 평가 항목

우선 ==반환시간(turnaround time)== 이라는 하나의 평가 기준을 사용한다.

$$T_{turnaround} = T_{completion} - T_{arrival}$$

-> 작업이 완료된 시간에서 도착한 시간을 뺀 시간으로 정의됨.

위의 가정에서 *작업은 동시에 도착한다고* 가정했으므로 $T_{arrival} = 0$ 
이라고 생각할 수 있음.

그러므로 $T_{turnaround} = T_{completion}$

반환시간은 ==성능== 측면에서의 평가기준이다. ==공정성==의 평가기준은 따로 있고 성능과 상충되는 목표이다.


#### 선입선출(FIFO)
가장 기초적인 알고리즘 중 하나로 선도착선처리(First Come First Served, FCFS) 라고도 함.

가장 먼저 들어온 프로세스 순대로 처리하는 것.

그런데 FIFO는 간단하지만 그렇게 좋은 스케줄링이 아니다.
[[Convoy effect]] 문제점이 생기기 때문.


#### 최단 작업 우선(SJF)
최단 작업 우선(Shortest Job Fast)은 이름 그 자체다. 가장 짧은 실행 시간을 가진 작업을 먼저 실행시킨다.

우리가 위에 한 가정인 
2. 모든 작업은 동시에 도착한다.
만 충족한다면 가장 완벽한 알고리즘이지만... 현실은 녹록치 않다.

만약 가장 작업이 많이 필요한 블럭이 들어오고 실행 중에 짧은 작업이 들어온다면 그대로 [[Convoy effect]]가 발생한다.

#### 최소 잔여시간 우선(STCF)
(=SJF, Shortest Job First)
최소 잔여시간 우선(Shortest Time-to-Completion First)는 위의 SJF에 선점 기능을 추가한 것이다.

언제든 새로운 작업이 시스템에 들어오면 이 스케줄러는 남아 있는 작업과 새로운 작업의 잔여 실행시간을 계산하여 가장 적은 잔여 실행 시간을 가진 작업을 스케줄한다.

#### 새로운 평가기준: 응답 시간(Response Time)

초기 일괄처리 컴퓨터 시스템에서는 이러한 알고리즘이 의미가 있었다.
하지만 시분할 컴퓨터의 등장으로 다른 평가기준이 필요하게 되었다.

응답시간은 작업이 도착할 때부터 처음 스케줄 될때까지의 시간으로 정의된다.

$$T_{response} = T_{firstrun}-T_{arrival}$$이 응답시간에 민감한 스케줄러를 만들 수 있을까?

#### 라운드 로빈(RR)
Round-Robin 은 작업이 끝날 때까지 기다리지 않는다. 대신 일정 시간 동안 실행하고 바로 큐로 넘긴다. 이때 작업시 실행되는 일정 시간을 ==타임 슬라이스(Time Slice)== 또는 ==스케줄링 퀀텀(Scheduling Quantum)==이라 부른다.

이러한 이유로 RR은 **타임 슬라이싱**이라 불린다.
타임 슬라이스의 길이는 타이머 인터럽트 주기의 배수여야 한다.
타이머가 10 msec 마다 인터럽트를 발생시키면 10, 20등이여야 함.

타임 슬라이스의 길이가 짧을수록 응답 시간 기준으로 RR의 성능은 좋아지지만 너무 짧게 지정하면 [[문맥 교환 비용]]이 너무 높아져 전체 성능이 하락할 수 있다.

공정성은 탁월하지만 반환 시간과 같은 평가 기준에서는 성능이 나쁘다.

#### 입출력을 고려해보자
입출력이 있다고 할 시 (원래는 입출력 항상 있기 때문)

